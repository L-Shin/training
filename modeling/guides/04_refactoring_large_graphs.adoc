= Refactoring large graphs
:icons: font

== Refactoring large graphs

In the previous section we noticed that our refactoring queries were slowing down once we'd loaded more flights into the database.

Can talk about doing this in batches and maybe introduce apoc?

The pattern is roughly this:

* tag all the nodes we need to process with some sort of flag label e.g. `Process`
* iterate over a subset of nodes flagged with that label and execute the refactoring
* remove the tag from the node
* return a count of how many rows were processed

When the count reaches 0 then we've finished.

== Manual batching

We're now sacrificing the atomicity that we'd get if we did everything in one transaction so it makes sense to make our refactoring queries idempotent in case we need to re-run them.
We also need to decide which node we're going to center the refactoring around.

To recap, this was the refactoring from the previous section:

[source, cypher]
----
MATCH (origin:Airport)<-[:ORIGIN]-(flight:Flight)-[:DESTINATION]->(destination:Airport)

MERGE (originAirportDay:AirportDay {id: origin.code + "_" + flight.year + "-" + flight.month + "-" + flight.day})
ON CREATE SET originAirportDay.date = flight.year + "-" + flight.month + "-" + flight.day

MERGE (destinationAirportDay:AirportDay {id: destination.code + "_" + flight.year + "-" + flight.month + "-" + flight.day})
ON CREATE SET destinationAirportDay.date = flight.year + "-" + flight.month + "-" + flight.day

MERGE (origin)-[:HAS_DAY]->(originAirportDay)
MERGE (originAirportDay)<-[:ORIGIN]-(flight)
MERGE (flight)-[:DESTINATION]-(destinationAirportDay)
----

Should probably make this an include since it's reused from the previous section.

`Flight` is probably the easiest place to start.

[source, cypher]
----
MATCH (f:Flight)
SET f:NeedsProcessing
----

So now all our `Flight` nodes have a `NeedsProcessing` label as well.

[source, cypher]
----
MATCH (flight:NeedsProcessing)
WITH flight LIMIT 500

MATCH (origin:Airport)<-[:ORIGIN]-(flight)-[:DESTINATION]->(destination:Airport)

MERGE (originAirportDay:AirportDay {id: origin.code + "_" + flight.year + "-" + flight.month + "-" + flight.day})
ON CREATE SET originAirportDay.date = flight.year + "-" + flight.month + "-" + flight.day

MERGE (destinationAirportDay:AirportDay {id: destination.code + "_" + flight.year + "-" + flight.month + "-" + flight.day})
ON CREATE SET destinationAirportDay.date = flight.year + "-" + flight.month + "-" + flight.day

MERGE (origin)-[:HAS_DAY]->(originAirportDay)
MERGE (originAirportDay)<-[:ORIGIN]-(flight)
MERGE (flight)-[:DESTINATION]-(destinationAirportDay)

RETURN COUNT(*)
----

We'd then have to run this query 100,000 / 500 = 200 times which would be a very boring way to pass the time.

Procedures were introduced in neo4j 3.0.0 and can massively simplify things for us here.

*link to the apoc guide*

== Batching with apoc

The `apoc.periodic.commit(statement,params)` stored procedure allows us to do just that.
Run the following query but be patient, it's got a lot of friendships to make!

[source,cypher]
----
call apoc.periodic.commit("
  <query>
",{limit:500})
----


Multiple models

You have to control the invariant from your application.
e.g. if an airline decides to cancel

Maybe this can be a slide based section?



Which date will make it easier to filter?
Should I load in all the flights for two of the hubs and have those in another CSV file?

Hmm multiple CSV files.

Our model looks good so far but let's import some more data and see how it fares as we add more queries.

We need to import some more of the dataset in so we can see the problem with dense nodes

It’s not a bad model, but we will have very dense nodes. Think about major hubs like Atlanta, Beijing, Dubai, London Heathrow, or even my local Chicago O’Hare. These would be very massive nodes with no quick way to filter routes without checking multiple properties which will slow our traversal down quite a bit.

When a user is trying to book a flight, they know where they are starting from, where they want to go, and what day they want to fly. So lets reimagine our model to introduce the concept of days.


As a user I want to book a flight from <origin> to <destination> on <date>



(airport)-[:HAS_DAY]->(airportDay)-[:HAS_FLIGHT]->(flight)

== Exercise

We want to introduce the concept of an `Airline` so that we can quickly find fights by our favorite airline without having to scan through all the flights.
Don't forget to connect the `Airline` nodes to the appropriate flights.

== Answer: Create `Airline` nodes

[source, cypher]
----
MATCH (flight:Flight)
MERGE (airline:Airline {code: flight.airline})
MERGE (flight)-[:AIRLINE]->(airline)
----

== Other ideas

We could even connect the different legs of the flight together?

Other modeling topics:

* Inferred relationships
* Maintaining multiple models for optimal write speed
