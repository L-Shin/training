= Flight as a first class citizen
:icons: font

== Flight as a first class citizen

In this section we're going to refactor the model to make `Flight` and `Airline` first class citizens in our domain.
This refactoring will make it much easier to write queries centered around these concepts.

== Finding flights

We can write the following query to find all the flights that we imported in the previous guide.

[source,cypher]
----
MATCH  (origin:Airport)-[flight:FLIGHT]->(destination:Airport)
RETURN *
LIMIT 10
----

== Creating flights

Neo4j only allows us to create constraints on single properties.
Unfortunately multi property constraints don't exist yet so we'll have to simulate that.

The combination of airline, flight number, and date makes a flight unique.
As we saw in the previous section, however, some flights can have multiple legs so we'll need to consider departure and arrival airports as well.
We'll create a `flightId` with this format: `{airline}{flightNumber}{year}-{month}-{day}_{origin}_{destination}`

Before we refactor to this model, look at the slides for a quick explanation of unique constraints and indexes which we'll use in the next section.

_Some sort of slide picture here_

== Creating flights

Run the following query to create a unique constraint on the `(Flight, id)` label/property pair.
This will ensure that we don't end up with any duplicate flights.

[source, cypher]
----
CREATE CONSTRAINT ON (f:Flight)
ASSERT f.id IS UNIQUE
----

Now we're reading to create `Flight` nodes.
Run the following query:

[source, cypher]
----
MATCH (origin:Airport)-[flight:FLIGHT]->(destination:Airport)
MERGE (newFlight:Flight { id: flight.airline + flight.flightNumber + "_" + flight.year + "-" + flight.month + "-" + flight.day + "_" + origin.code + "_" + destination.code }   )
ON CREATE SET newFlight.year = flight.year,
              newFlight.month = flight.month,
              newFlight.day = flight.day,
              newFlight.airline = flight.airline,
              newFlight.number = flight.flightNumber,
              newFlight.departure = flight.departure,
              newFlight.arrival = flight.arrival
MERGE (origin)<-[:ORIGIN]-(newFlight)
MERGE (newFlight)-[:DESTINATION]->(destination)
----

This query:

* finds all `(origin, flight, destination)` paths
* creates a `Flight` node if one doesn't already exist
* creates an `ORIGIN` relationship to the origin airport and a `DESTINATION` relationship to the destination airport

Now we can try our earlier query again.

= Find all the flights for flight number `WN 1016`

First let's create an index on `(Flight, number)` so that we can quickly find the appropriate flights.

[source, cypher]
----
CREATE INDEX ON :Flight(number)
----

[source, cypher]
----
MATCH (origin)<-[:ORIGIN]-(flight:Flight)-[:DESTINATION]->(destination)
WHERE flight.airline = "WN" AND flight.number = "1016"
RETURN origin.code, destination.code, flight.year, flight.month, flight.day, flight.departure, flight.arrival
ORDER BY flight.year, flight.month, flight.day, flight.departure
----

Before we delete the `FLIGHT` relationship we should profile the two versions of the query to see whether our refactoring has improved things.

= Profiling queries

_Get people to look at the slides & explain how to profile a query_

= Profiling the two flight models

Original query

[source, cypher]
----
PROFILE
MATCH  (origin:Airport)-[flight:FLIGHT]->(destination:Airport)
WHERE flight.airline = "WN" AND flight.flightNumber = "1016"
RETURN origin.code, destination.code, flight.year, flight.month, flight.day, flight.departure, flight.arrival
ORDER BY flight.year, flight.month, flight.day, flight.departure
----

With `Flight` as a first class citizen

[source, cypher]
----
PROFILE
MATCH (origin)<-[:ORIGIN]-(flight:Flight)-[:DESTINATION]->(destination)
WHERE flight.airline = "WN" AND flight.number = "1016"
RETURN origin.code, destination.code, flight.year, flight.month, flight.day, flight.departure, flight.arrival
ORDER BY flight.year, flight.month, flight.day, flight.departure
----

It looks like a good refactoring - the 2nd query does 20x less work.
Let's get rid of the `FLIGHT` relationship between airports.

= Deleting the `FLIGHT` relationship

Run the following query to delete the `FLIGHT` relationship we initially created between origin and destination airports:

[source, cypher]
----
MATCH (origin)<-[:ORIGIN]-(flight:Flight)-[:DESTINATION]->(destination)
DELETE flight
----

Our model looks good so far but let's



= Import moar data

Our model looks good so far but let's import some more data and see how it fares as we add more queries.

We need to import some more of the dataset in so we can see the problem with dense nodes

It’s not a bad model, but we will have very dense nodes. Think about major hubs like Atlanta, Beijing, Dubai, London Heathrow, or even my local Chicago O’Hare. These would be very massive nodes with no quick way to filter routes without checking multiple properties which will slow our traversal down quite a bit.

When a user is trying to book a flight, they know where they are starting from, where they want to go, and what day they want to fly. So lets reimagine our model to introduce the concept of days.

[verse]
____
As a frequent traveller
I want to find flights from <origin> to <destination> on <date>
So that I can book my business flight
____


As a user I want to book a flight from <origin> to <destination> on <date>



(airport)-[:HAS_DAY]->(airportDay)-[:HAS_FLIGHT]->(flight)

== Exercise

We want to introduce the concept of an `Airline` so that we can quickly find fights by our favorite airline without having to scan through all the flights.
Don't forget to connect the `Airline` nodes to the appropriate flights.

== Answer: Create `Airline` nodes

[source, cypher]
----
MATCH (flight:Flight)
MERGE (airline:Airline {code: flight.airline})
MERGE (flight)-[:AIRLINE]->(airline)
----

== Other ideas

We could even connect the different legs of the flight together?

Other modeling topics:

* Inferred relationships
* Maintaining multiple models for optimal write speed

== Next Step

In the next section we're going to do something else, who knows what it'll be yet:

pass:a[<a play-topic='{guides}/02_flight.html'>Flight as a first class citizen</a>]
