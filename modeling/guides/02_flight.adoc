= Flight as a first class citizen
:icons: font

== Flight as a first class citizen

In this section we're going to profile the query from the end of the last section and see what's going on under the covers.

We'll then refactor the model to introduce `Flight` as a first class citizen in our domain to make it easier to write queries centered around flights.

Before we profile our query a quick explanation:

image::{img}/slides.jpg[]

== Profiling flight `WN 1016`

We can profile our query by prefixing it with the `PROFILE` keyword:

[source, cypher]
----
PROFILE
MATCH (origin:Airport)-[flight:FLIGHT]->(destination:Airport)
WHERE flight.airline = "WN" AND flight.flightNumber = "1016"
RETURN origin.code, destination.code, flight.year, flight.month, flight.day, flight.departure, flight.arrival
ORDER BY flight.year, flight.month, flight.day, flight.departure
----

What we get back is an execution plan which describes the Cypher operators used to execute this query.
You can read more about these in the link:https://neo4j.com/docs/developer-manual/current/cypher/#execution-plans[developer manual]

In this one the query starts with a `NodeByLabelScan` on the `:Airport` label, which means that we first scanned all the airports.
Next we followed the `FLIGHT` relationship to `origin` airports, and we can see from the `estimated rows` count that we followed 10,000 of these.

That's a lot of flights!

== Scanning all the flights

In fact we actually looked at every single flight, which we can confirm by executing the following query:

[source, cypher]
----
MATCH ()-[:FLIGHT]->()
RETURN COUNT(*)
----

So it's clear that our model isn't optimal - we're doing far too much work just to find the destinations and origins of one flight.

It's time to refactor the model.

== Introducing flight as a first class citizen

Having convinced ourselves that our current model is quite inefficient, we're going to refactor the model to introduce a `Flight` node:

image::{img}/flight_first_class.png[width=100%]

== Creating flights

When we refactor the model we want to make sure we only create each flight once.
Neo4j allows us to create unique constraints to ensure uniqueness across a label/property pair.

Before we refactor our model, look at the slides for a quick explanation of unique constraints and indexes which we'll use in the next section.

image::{img}/slides.jpg[]

== Ensuring flight uniqueness

At the moment Neo4j only allows us to create constraints on single properties.
In our case we want to ensure uniqueness across several properties so we'll combine those together into a single dummy property.

The combination of airline, flight number, and date makes a flight unique.
As we saw in the previous section, however, some flights can have multiple legs so we'll need to consider departure and arrival airports as well.
We'll create a `flightId` with this format: `{airline}{flightNumber}{year}-{month}-{day}_{origin}_{destination}`

Run the following query to create a unique constraint on the `Flight/id` label/property pair:

[source, cypher]
----
CREATE CONSTRAINT ON (f:Flight)
ASSERT f.id IS UNIQUE
----

Ok, now let the refactoring begin.

== Creating flights

Now we're reading to create `Flight` nodes.
Run the following query:

[source, cypher]
----
MATCH (origin:Airport)-[flight:FLIGHT]->(destination:Airport)
MERGE (newFlight:Flight { id: flight.airline + flight.flightNumber + "_" + flight.year + "-" + flight.month + "-" + flight.day + "_" + origin.code + "_" + destination.code }   )
ON CREATE SET newFlight.year = flight.year,
              newFlight.month = flight.month,
              newFlight.day = flight.day,
              newFlight.airline = flight.airline,
              newFlight.number = flight.flightNumber,
              newFlight.departure = flight.departure,
              newFlight.arrival = flight.arrival
MERGE (origin)<-[:ORIGIN]-(newFlight)
MERGE (newFlight)-[:DESTINATION]->(destination)
----

This query:

* finds all `(origin, flight, destination)` paths
* creates a `Flight` node if one doesn't already exist
* creates an `ORIGIN` relationship to the origin airport and a `DESTINATION` relationship to the destination airport

Now we can try our earlier query again.

== Find all the flights for flight number `WN 1016`

First let's create an index on `(Flight, number)` so that we can quickly find the appropriate flights.

[source, cypher]
----
CREATE INDEX ON :Flight(number)
----

Now we're ready to find those flights!

[source, cypher]
----
MATCH (origin)<-[:ORIGIN]-(flight:Flight)-[:DESTINATION]->(destination)
WHERE flight.airline = "WN" AND flight.number = "1016"
RETURN origin, destination, flight
----

Before we delete the `FLIGHT` relationship we should profile the two versions of the query to see whether our refactoring has improved things.

== Exercise: Profiling the two flight models

Let's now profile our new version of the query to see if we've improved things:

[source, cypher]
----
PROFILE
MATCH (origin)<-[:ORIGIN]-(flight:Flight)-[:DESTINATION]->(destination)
WHERE flight.airline = "WN" AND flight.number = "1016"
RETURN origin, destination, flight
----

For reference, you can re-run the profile on our other query as well:

[source, cypher]
----
PROFILE
MATCH (origin:Airport)-[flight:FLIGHT]->(destination:Airport)
WHERE flight.airline = "WN" AND flight.flightNumber = "1016"
RETURN origin, destination, flight
----

What do you notice?

== Answer: Profiling the two flight models

It looks like a good refactoring - we can see by comparing the `db hits` that the 2nd query does 20x less work

This is because we no longer have to *scan every flight* looking for ones which have an `airline` of `WN` and a `number` of `1016`.
Instead we're able to use the `:Flight(number)` index to find the flights we're interested in and only determine the origins and destinations for those flights.

== Deleting the `FLIGHT` relationship

Since the `FLIGHT` relationship between airports doesn't seem to be much use anymore, let's delete.

Run the following query:

[source, cypher]
----
MATCH ()-[flight:FLIGHT]->()
DELETE flight
----

== Next Step

In the next section we're going to write some more queries against the dataset, but this time with a different user in mind.

pass:a[<a play-topic='{guides}/03_flight_booking.html'>Flight booking</a>]
