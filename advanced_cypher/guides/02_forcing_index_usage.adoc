= Forcing queries to use indexes
:icons: font

== Forcing queries to use indexes

Let's import the full movies dataset

[source, cypher, subs=attributes]
----
LOAD CSV WITH HEADERS FROM '{csv-url}people.csv' as row

MERGE(person:Person {id: toInt(row.personId)})
ON CREATE SET person.name = row.name,
              person.born = toInt(row.birthYear),
              person.died = toInt(row.deathYear)
----

[source, cypher, subs=attributes]
----
LOAD CSV WITH HEADERS FROM '{csv-url}new_movies.csv' as row

MERGE (movie:Movie {id:toInt(row.movieId)})
ON CREATE SET
  movie.title = row.title,
  movie.avgVote = toFloat(row.avgVote),
  movie.releaseYear = toInt(row.releaseYear),
  movie.tagline = row.tagline,
  movie.genres = split(row.genres, ":")
----

[source, cypher, subs=attributes]
----
LOAD CSV WITH HEADERS FROM '{csv-url}directors.csv' as row

MATCH (movie:Movie {id:toInt(row.movieId)})
MATCH (person:Person {id: toInt(row.personId)})
MERGE (person)-[:DIRECTED]->(movie)
----

[source, cypher, subs=attributes]
----
LOAD CSV WITH HEADERS FROM '{csv-url}actors.csv' as row

MATCH (movie:Movie {id:toInt(row.movieId)})
MATCH (person:Person {id: toInt(row.personId)})

MERGE (person)-[actedIn:ACTED_IN]->(movie)
ON CREATE SET actedIn.roles = CASE WHEN row.characters IS NULL then [] ELSE split(row.characters, ":") END
----

== Query time

Let's write some queries against the dataset now.

Complex aggregates?

We'll start with a simple aggregate query.
Run the following query to find the person who's acted in the most movies:

[source, cypher]
----
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
RETURN a.name, count(*)
ORDER BY count(*) DESC
LIMIT 10
----

Let's profile this query by prefixing it with `PROFILE`:

[source, cypher]
----
PROFILE
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
RETURN a.name, count(*)
ORDER BY count(*) DESC
LIMIT 10
----

From the execution plan we can see that it's doing an unnecessary `Projection` on `a.name`.
By grouping on the `name` property we are forcing Cypher to look up the name of every `Person` in the database when we're only interested in the ten most prolific ones.

== Lazy property evaluation

Instead of that let's group on the node and then look up the `name` property only for the top 10 actors.
The following query does this:

[source, cypher]
----
PROFILE
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
WITH a, count(*) as count
ORDER BY count DESC
LIMIT 10
RETURN a.name, count
----

We can do even better if we don't specify the `:Movie` label on the right hand side of the `ACTED_IN` relationship.
Since this database only contains people acting in movies it's unnecessary for this query.

Having said that, there are less movies than people in this dataset so the query does actually start from `:Movie` and go back.
But we know we're not interested in movies so let's get rid of it:

[source, cypher]
----
PROFILE
MATCH (a:Person)-[:ACTED_IN]->()
WITH a, count(*) as count
ORDER BY count DESC
LIMIT 10
RETURN a.name, count
----

Can we do even better?

== The Count Store

Explain the count store and what it's able to count

== Count Store / No Count Store

Let's try a few queries to get the hang of where it's being used and what type of count operations we should expect to be fast.

All nodes = count store

[source, cypher]
----
PROFILE MATCH () RETURN COUNT(*)
----

Nodes with a label = count store

[source, cypher]
----
PROFILE MATCH (:Person) RETURN COUNT(*)
----

Nodes with multiple labels = no count store

[source, cypher]
----
PROFILE MATCH (:Person:Engineer) RETURN COUNT(*)
----

No direction on relationship = no count store

[source, cypher]
----
PROFILE MATCH (:Movie)-[:ACTED_IN]-() RETURN COUNT(*)
----

Direction on relationship = count store

[source, cypher]
----
PROFILE MATCH (:Movie)<-[:ACTED_IN]-() RETURN COUNT(*)
----

Label on both sides of relationship = no count store

[source, cypher]
----
PROFILE MATCH (:Movie)<-[:ACTED_IN]-(:Person) RETURN COUNT(*)
----


Find all the people who have acted in <x> movies and directed <y> movies

== Using our count store knowledge

[source, cypher]
----
PROFILE
MATCH (a:Person)
WITH a, SIZE((a)-[:ACTED_IN]->()) AS count
ORDER BY count DESC
LIMIT 10
RETURN a.name, count
----

The count store is sometimes used by Cypher anyway but on this occasion it wasn't.
It keeps track of counts of various cardinalities.
